{% extends "base.html" %}
{% block content %}
<section class="card wide capture-card">
  <div class="card-header">
    <div>
      <p class="eyebrow">Realtime capture</p>
      <h1>Create a new data session</h1>
    </div>
    <div class="status-pill {{ state.status }}">
      <span class="dot"></span>
      <span class="label">{{ state.status|capitalize }}</span>
    </div>
  </div>
  <form id="capture-form" class="form-grid">
    <label>
      <span>Session name</span>
      <input type="text" name="sessionName" placeholder="e.g. desk-evening" required />
    </label>
    <label>
      <span>Duration (minutes)</span>
      <input type="number" name="durationMinutes" value="5" min="0.5" step="0.5" required />
    </label>
    <label>
      <span>Interval between shots (seconds)</span>
      <input type="number" name="intervalSeconds" value="3" min="0.2" step="0.1" required />
    </label>
    <label>
      <span>Split</span>
      <select name="splitName" id="split-select">
        <option value="train">Train</option>
        <option value="val">Validation</option>
        <option value="test">Test</option>
      </select>
    </label>
    <button type="submit" class="primary">Start capture</button>
  </form>
  <p class="helper-text">
    The capture runs in the background. Keep this server running and your webcam unobstructed.
  </p>
</section>

<div class="compact-grid">
  <section class="card status-card compact">
    <div class="status-card-header">
      <div>
        <p class="eyebrow">Progress</p>
        <h2>Capture status</h2>
      </div>
      <span class="pill" id="status-label">{{ state.status|capitalize }}</span>
    </div>
    <div class="status-layout">
      <div class="status-progress">
        <div class="status-line">
          <span>Frames</span>
          <strong id="captured-count">{{ state.captured }}</strong>
        </div>
        <div class="status-line">
          <span>Split</span>
          <strong id="current-split">{% if state.split %}{{ state.split }}{% else %}-{% endif %}</strong>
        </div>
        <div class="status-line">
          <span>Remaining</span>
          <strong id="remaining-time">{% if state.remaining %}{{ "%.1f"|format(state.remaining) }}s{% else %}-{% endif %}</strong>
        </div>
        <div class="progress slim">
          <div id="progress-fill" style="width: {{ (state.progress or 0)*100 }}%"></div>
        </div>
      </div>
      <div class="status-feedback">
        <p id="status-message">{{ state.message or "Ready to go." }}</p>
        <div class="status-actions">
          <button id="cancel-btn" class="ghost" {% if state.status != 'running' %}disabled{% endif %}>Cancel</button>
          <a class="outline" href="{{ url_for('sessions_view') }}">Sessions</a>
        </div>
      </div>
    </div>
  </section>

  <section class="card preview-card compact">
    <div class="card-header small">
      <div>
        <p class="eyebrow">Live preview</p>
        <h3>Camera feedback</h3>
      </div>
      <span class="helper-text">Only visible while capturing.</span>
    </div>
    <div class="preview-frame small">
      <img id="live-preview" alt="Live preview will appear during capture." />
      <div id="preview-placeholder" class="preview-placeholder">
        <p>Launch a capture to see your camera feed.</p>
      </div>
    </div>
  </section>
</div>

<script>
  const statePollUrl = "{{ url_for('status_endpoint') }}";
  const startUrl = "{{ url_for('start_endpoint') }}";
  const cancelUrl = "{{ url_for('cancel_endpoint') }}";
  const previewUrl = "{{ url_for('preview_endpoint') }}";
  let pollingHandle = null;
  let previewHandle = null;

  const captureForm = document.getElementById("capture-form");
  const statusLabel = document.getElementById("status-label");
  const capturedCount = document.getElementById("captured-count");
  const currentSplit = document.getElementById("current-split");
  const remainingTime = document.getElementById("remaining-time");
  const progressFill = document.getElementById("progress-fill");
  const statusMessage = document.getElementById("status-message");
  const cancelBtn = document.getElementById("cancel-btn");
  const previewImg = document.getElementById("live-preview");
  const previewPlaceholder = document.getElementById("preview-placeholder");
  const splitSelect = document.getElementById("split-select");
  const initialSplit = "{{ state.split or '' }}";
  if (initialSplit && ["train", "val", "test"].includes(initialSplit)) {
    splitSelect.value = initialSplit;
  } else {
    splitSelect.value = "train";
  }

  function updateStatusView(payload) {
    statusLabel.textContent = payload.status.charAt(0).toUpperCase() + payload.status.slice(1);
    capturedCount.textContent = payload.captured ?? 0;
    currentSplit.textContent = payload.split || "-";
    if (payload.status === "running" && payload.split && ["train", "val", "test"].includes(payload.split)) {
      splitSelect.value = payload.split;
    }
    if (payload.remaining != null) {
      remainingTime.textContent = `${payload.remaining.toFixed(1)}s`;
    } else {
      remainingTime.textContent = "-";
    }
    progressFill.style.width = `${Math.min((payload.progress || 0) * 100, 100)}%`;
    statusMessage.textContent = payload.message || "";
    cancelBtn.disabled = payload.status !== "running";
    togglePreview(payload.status === "running");
  }

  async function pollStatus() {
    try {
      const response = await fetch(statePollUrl);
      const payload = await response.json();
      updateStatusView(payload);
    } catch (error) {
      console.error("Unable to poll state", error);
    } finally {
      pollingHandle = setTimeout(pollStatus, 2000);
    }
  }

  captureForm.addEventListener("submit", async (event) => {
    event.preventDefault();
    const formData = new FormData(captureForm);
    const payload = Object.fromEntries(formData.entries());
    payload.durationMinutes = Number(payload.durationMinutes);
    payload.intervalSeconds = Number(payload.intervalSeconds);
    try {
      const response = await fetch(startUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });
      const data = await response.json();
      if (!response.ok) {
        alert(data.error || "Unable to start capture.");
        return;
      }
      if (data.split && ["train", "val", "test"].includes(data.split)) {
        currentSplit.textContent = data.split;
      }
      statusMessage.textContent = "Capture started. You can navigate away.";
      if (!pollingHandle) pollStatus();
    } catch (error) {
      alert("Failed to start capture. See console for details.");
      console.error(error);
    }
  });

  cancelBtn.addEventListener("click", async () => {
    try {
      await fetch(cancelUrl, { method: "POST" });
    } catch (error) {
      console.error(error);
    }
  });

  function togglePreview(isRunning) {
    if (isRunning) {
      previewPlaceholder.style.display = "none";
      if (!previewHandle) {
        previewHandle = setTimeout(refreshPreview, 0);
      }
    } else {
      previewPlaceholder.style.display = "flex";
      if (previewHandle) {
        clearTimeout(previewHandle);
        previewHandle = null;
      }
      previewImg.removeAttribute("src");
    }
  }

  async function refreshPreview() {
    try {
      const response = await fetch(`${previewUrl}?t=${Date.now()}`, { cache: "no-store" });
      if (response.ok) {
        const blob = await response.blob();
        const objectUrl = URL.createObjectURL(blob);
        previewImg.src = objectUrl;
        setTimeout(() => URL.revokeObjectURL(objectUrl), 500);
      }
    } catch (error) {
      console.error("Preview update failed", error);
    } finally {
      previewHandle = setTimeout(refreshPreview, 1000);
    }
  }

  pollStatus();
</script>
{% endblock %}
