{% extends "base.html" %}
{% block content %}
<section class="card wide annotation-shell">
  <div class="card-header">
    <div>
      <p class="eyebrow">Annotate 路 {{ split|capitalize }} split</p>
      <h1>Session {{ session_id }}</h1>
    </div>
    <a class="outline" href="{{ url_for('sessions_view') }}">Back to sessions</a>
  </div>

  <div class="annotation-layout">
    <div class="image-frame">
      <button id="prev-button" type="button" class="nav-button prev" aria-label="Previous frame">&larr;</button>
      <img id="frame" src="" alt="Captured frame" />
      <button id="next-button" type="button" class="nav-button next" aria-label="Next frame">&rarr;</button>
    </div>
    <div class="annotation-controls">
      <h2>Choose a label</h2>
      <div class="button-stack">
        <button class="primary large" data-label="biting">Biting nails (B)</button>
        <button class="secondary large" data-label="not_biting">Not biting (N)</button>
      </div>
      <p class="helper-text">Use keyboard shortcuts: B for biting, N for not biting.</p>
      <p id="progress-label" class="progress-label"></p>
    </div>
  </div>
</section>

<script>
  const split = "{{ split }}";
  const annotateUrl = "{{ url_for('annotate_endpoint', split=split, session_id=session_id) }}";
  const images = {{ images_json|safe }};
  const placeholderUrl = "{{ url_for('serve_image', split=split, session_id=session_id, filename='__FILE__') }}";
  let currentIndex = Math.min({{ start_index }}, Math.max(images.length - 1, 0));
  let annotatedCount = images.filter((entry) => entry.label).length;

  const imgEl = document.getElementById("frame");
  const progressLabel = document.getElementById("progress-label");
  const buttons = document.querySelectorAll("button[data-label]");
  const prevButton = document.getElementById("prev-button");
  const nextButton = document.getElementById("next-button");

  function formatLabel(label) {
    if (label === "biting") return "Biting nails";
    if (label === "not_biting") return "Not biting";
    return "Unlabeled";
  }

  function updateActiveLabelButton(activeLabel) {
    buttons.forEach((btn) => {
      const isActive = btn.dataset.label === activeLabel;
      btn.classList.toggle("is-active", isActive);
      btn.setAttribute("aria-pressed", isActive ? "true" : "false");
    });
  }

  function updateView() {
    if (!images.length) {
      imgEl.alt = "No frames available.";
      imgEl.src = "";
      progressLabel.textContent = "No frames available for annotation.";
      buttons.forEach((btn) => (btn.disabled = true));
      updateActiveLabelButton(null);
      prevButton.disabled = true;
      nextButton.disabled = true;
      return;
    }
    const current = images[currentIndex];
    imgEl.src = placeholderUrl.replace("__FILE__", encodeURIComponent(current.filename)) + `?t=${Date.now()}`;
    imgEl.alt = current.filename;
    const positionStatus = `Viewing ${currentIndex + 1} / ${images.length}`;
    const totalStatus = `${annotatedCount} / ${images.length} annotated`;
    const labelStatus = `Current: ${formatLabel(current.label)}`;
    if (annotatedCount >= images.length) {
      progressLabel.textContent = `All frames annotated. Use arrows or buttons to review. ${positionStatus} 路 ${labelStatus}`;
    } else {
      progressLabel.textContent = `${totalStatus} 路 ${positionStatus} 路 ${labelStatus}`;
    }
    buttons.forEach((btn) => (btn.disabled = false));
    updateActiveLabelButton(current.label);
    const disableNav = images.length <= 1;
    prevButton.disabled = disableNav;
    nextButton.disabled = disableNav;
  }

  async function submitLabel(label) {
    if (!images.length) return;
    const current = images[currentIndex];
    try {
      const response = await fetch(annotateUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ filename: current.filename, label }),
      });
      const payload = await response.json();
      if (!response.ok) {
        alert(payload.error || "Unable to save label.");
        return;
      }
      if (!current.label) annotatedCount += 1;
      current.label = label;
      moveNext({ skipAnnotated: true });
    } catch (error) {
      alert("Unable to save label. Check the console for details.");
      console.error(error);
    }
  }

  function findNextUnannotated(startIndex) {
    for (let offset = 1; offset <= images.length; offset += 1) {
      const idx = (startIndex + offset) % images.length;
      if (!images[idx].label) return idx;
    }
    return null;
  }

  function moveNext(options = {}) {
    if (!images.length) return;
    const skipAnnotated = Boolean(options.skipAnnotated);
    if (skipAnnotated) {
      const nextIdx = findNextUnannotated(currentIndex);
      if (nextIdx !== null) {
        currentIndex = nextIdx;
        updateView();
        return;
      }
    }
    currentIndex = (currentIndex + 1) % images.length;
    updateView();
  }

  function movePrevious() {
    if (!images.length) return;
    currentIndex = (currentIndex - 1 + images.length) % images.length;
    updateView();
  }

  buttons.forEach((btn) => {
    btn.addEventListener("click", () => submitLabel(btn.dataset.label));
  });

  prevButton.addEventListener("click", () => movePrevious());
  nextButton.addEventListener("click", () => moveNext());

  window.addEventListener("keydown", (event) => {
    const key = event.key.toLowerCase();
    const tagName = event.target.tagName;
    const isFormField = tagName === "INPUT" || tagName === "TEXTAREA";
    if (event.metaKey || event.ctrlKey || event.altKey || isFormField) {
      return;
    }
    if (key === "arrowleft") {
      event.preventDefault();
      movePrevious();
      return;
    }
    if (key === "arrowright") {
      event.preventDefault();
      moveNext();
      return;
    }
    if (key === "b") {
      event.preventDefault();
      submitLabel("biting");
    }
    if (key === "n") {
      event.preventDefault();
      submitLabel("not_biting");
    }
  });

  updateView();
</script>
{% endblock %}
