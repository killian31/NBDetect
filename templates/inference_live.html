{% extends "base_watch.html" %}
{% block content %}
<section class="card wide capture-card">
  <div class="card-header">
    <div>
      <p class="eyebrow">Realtime watch</p>
      <h1>NBDetect monitor</h1>
    </div>
    <span class="pill">{{ state.status|capitalize }}</span>
  </div>
  <div class="control-grid">
    <label>
      <span>Alert threshold</span>
      <input type="range" id="threshold" min="0.1" max="0.95" step="0.05" value="{{ state.threshold }}" />
      <small class="helper-text">Trigger alert when biting probability â‰¥ <span id="threshold-value">{{ state.threshold }}</span></small>
    </label>
    <label>
      <span>Input image size</span>
      <div class="input-row">
        <input type="number" id="image-size" min="64" max="1024" step="32" value="{{ state.image_size }}" />
        <button id="apply-image-size" class="ghost">Apply</button>
      </div>
      <small class="helper-text">Match the resolution your model expects (e.g., 224 or 512).</small>
    </label>
    <div class="button-set full">
      <button id="start-btn" class="primary" disabled>Start monitoring</button>
      <button id="stop-btn" class="ghost" disabled>Stop</button>
    </div>
    <p class="helper-text full-row">Using model: <span id="model-path-display">{{ state.model_path or "runs/mobilenetv2_2500/epoch_10.pt" }}</span></p>
  </div>
</section>

<div class="monitor-grid">
  <section class="card compact preview-card">
    <div class="card-header small">
      <div>
        <p class="eyebrow">Live feed</p>
        <h2>Camera stream</h2>
      </div>
      <span class="helper-text">Alerts freeze the stream until acknowledged.</span>
    </div>
    <div class="preview-frame small">
      <img id="video-feed" data-stream-url="{{ url_for('video_feed') }}" src="{{ url_for('video_feed') }}" alt="Video feed appears once monitoring starts." />
      <div id="overlay-alert" class="alert-overlay hidden">
        <div class="alert-box">
          <p class="eyebrow">Warning</p>
          <h3>Nail biting detected</h3>
          <p>Resume monitoring to continue.</p>
          <button id="ack-btn" class="primary">Resume monitoring</button>
        </div>
      </div>
    </div>
  </section>

  <section class="card status-card compact">
    <div class="status-card-header">
      <div>
        <p class="eyebrow">Status</p>
        <h2>Detection summary</h2>
      </div>
    </div>
    <div class="status-layout">
      <div class="status-progress">
        <div class="status-line">
          <span>Biting probability</span>
          <strong id="biting-prob">{{ state.probabilities.biting }}</strong>
        </div>
        <div class="status-line">
          <span>Not biting probability</span>
          <strong id="not-biting-prob">{{ state.probabilities.not_biting }}</strong>
        </div>
        <div class="status-line">
          <span>Last detection</span>
          <strong id="last-detection">{% if state.last_detection %}{{ state.last_detection }}{% else %}-{% endif %}</strong>
        </div>
      </div>
      <div class="status-feedback">
        <p id="status-message">{{ state.message }}</p>
      </div>
    </div>
  </section>
</div>

<script>
  const statusUrl = "{{ url_for('status_route') }}";
  const startUrl = "{{ url_for('start_route') }}";
  const stopUrl = "{{ url_for('stop_route') }}";
  const ackUrl = "{{ url_for('acknowledge_route') }}";
  const thresholdUrl = "{{ url_for('threshold_route') }}";
  const imageSizeUrl = "{{ url_for('image_size_route') }}";

  const thresholdInput = document.getElementById("threshold");
  const thresholdValue = document.getElementById("threshold-value");
  const imageSizeInput = document.getElementById("image-size");
  const applyImageSizeBtn = document.getElementById("apply-image-size");
  const startBtn = document.getElementById("start-btn");
  const stopBtn = document.getElementById("stop-btn");
  const overlay = document.getElementById("overlay-alert");
  const ackBtn = document.getElementById("ack-btn");
  const statusMessage = document.getElementById("status-message");
  const bitingProbEl = document.getElementById("biting-prob");
  const notBitingProbEl = document.getElementById("not-biting-prob");
  const lastDetectionEl = document.getElementById("last-detection");
  const modelPathDisplay = document.getElementById("model-path-display");

  let modelReady = {{ "true" if state.model_path else "false" }};
  if (modelReady) startBtn.disabled = false;
  if (modelPathDisplay && !modelPathDisplay.textContent.trim()) {
    modelPathDisplay.textContent = "runs/mobilenetv2_2500/epoch_10.pt";
  }

  let alertActive = false;
  let notificationPermissionRequested = false;
  let audioContext = null;
  let alertOscillator = null;
  let toneTimeout = null;

  thresholdInput.addEventListener("input", () => {
    thresholdValue.textContent = Number(thresholdInput.value).toFixed(2);
  });

  thresholdInput.addEventListener("change", () => {
    updateThreshold(Number(thresholdInput.value));
  });

  applyImageSizeBtn.addEventListener("click", async () => {
    const value = Number(imageSizeInput.value);
    if (!value || value < 64 || value > 1024) {
      alert("Enter an image size between 64 and 1024.");
      return;
    }
    try {
      const response = await fetch(imageSizeUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ image_size: value }),
      });
      if (!response.ok) {
        const payload = await response.json();
        alert(payload.error || "Failed to apply image size.");
      }
    } catch (error) {
      console.error("Failed to update image size", error);
    }
  });

  startBtn.addEventListener("click", async () => {
    prepareAlertSystems();
    try {
      const response = await fetch(startUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ threshold: Number(thresholdInput.value) }),
      });
      const payload = await response.json();
      if (!response.ok) {
        alert(payload.error || "Unable to start monitoring.");
        return;
      }
      startBtn.disabled = true;
      stopBtn.disabled = false;
    } catch (error) {
      console.error(error);
    }
  });

  stopBtn.addEventListener("click", async () => {
    try {
      await fetch(stopUrl, { method: "POST" });
      stopBtn.disabled = true;
      startBtn.disabled = false;
      overlay.classList.add("hidden");
      stopAlertTone();
      alertActive = false;
    } catch (error) {
      console.error(error);
    }
  });

  ackBtn.addEventListener("click", async () => {
    try {
      await fetch(ackUrl, { method: "POST" });
    } catch (error) {
      console.error(error);
    } finally {
      overlay.classList.add("hidden");
      stopAlertTone();
      alertActive = false;
    }
  });

  async function updateThreshold(value) {
    thresholdValue.textContent = value.toFixed(2);
    try {
      await fetch(thresholdUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ threshold: value }),
      });
    } catch (error) {
      console.error(error);
    }
  }

  async function pollStatus() {
    try {
      const response = await fetch(statusUrl);
      const payload = await response.json();
      bitingProbEl.textContent = payload.probabilities.biting.toFixed(2);
      notBitingProbEl.textContent = payload.probabilities.not_biting.toFixed(2);
      statusMessage.textContent = payload.message || "";
      lastDetectionEl.textContent = payload.last_detection || "-";

      if (Math.abs(payload.threshold - Number(thresholdInput.value)) > 1e-3) {
        thresholdInput.value = payload.threshold;
        thresholdValue.textContent = Number(payload.threshold).toFixed(2);
      }

      if (payload.model_path && modelPathDisplay) {
        modelReady = true;
        modelPathDisplay.textContent = payload.model_path;
      }

      if (payload.status === "running" || payload.alert) {
        startBtn.disabled = true;
        stopBtn.disabled = false;
      } else {
        stopBtn.disabled = true;
        startBtn.disabled = !modelReady;
      }

      if (payload.alert) {
        overlay.classList.remove("hidden");
        if (!alertActive) {
          alertActive = true;
          triggerAlertEffects();
        }
      } else {
        overlay.classList.add("hidden");
        if (alertActive) {
          stopAlertTone();
          alertActive = false;
        }
      }
    } catch (error) {
      console.error("Status poll failed", error);
    } finally {
      setTimeout(pollStatus, 1200);
    }
  }

  function prepareAlertSystems() {
    if (!notificationPermissionRequested && "Notification" in window) {
      Notification.requestPermission();
      notificationPermissionRequested = true;
    }
    if (!audioContext && (window.AudioContext || window.webkitAudioContext)) {
      try {
        const Ctor = window.AudioContext || window.webkitAudioContext;
        audioContext = new Ctor();
      } catch (error) {
        console.warn("Unable to initialize audio context", error);
      }
    }
  }

  function triggerAlertEffects() {
    playAlertTone();
    showSystemNotification();
  }

  function playAlertTone() {
    if (!audioContext) {
      prepareAlertSystems();
    }
    if (!audioContext) {
      return;
    }
    if (audioContext.state === "suspended") {
      audioContext.resume().catch(() => {});
    }
    stopAlertTone();
    alertOscillator = audioContext.createOscillator();
    const gain = audioContext.createGain();
    alertOscillator.type = "square";
    alertOscillator.frequency.setValueAtTime(880, audioContext.currentTime);
    gain.gain.setValueAtTime(0.0001, audioContext.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.25, audioContext.currentTime + 0.05);
    gain.gain.exponentialRampToValueAtTime(0.002, audioContext.currentTime + 1.5);
    alertOscillator.connect(gain).connect(audioContext.destination);
    alertOscillator.start();
    toneTimeout = setTimeout(stopAlertTone, 1600);
  }

  function stopAlertTone() {
    if (toneTimeout) {
      clearTimeout(toneTimeout);
      toneTimeout = null;
    }
    if (alertOscillator) {
      try {
        alertOscillator.stop();
      } catch (_) {}
      alertOscillator.disconnect();
      alertOscillator = null;
    }
  }

  function showSystemNotification() {
    if (!("Notification" in window)) {
      return;
    }
    if (Notification.permission === "granted") {
      new Notification("NBDetect", {
        body: "Nail biting detected!",
        requireInteraction: true,
      });
    }
  }

  pollStatus();
</script>
{% endblock %}
