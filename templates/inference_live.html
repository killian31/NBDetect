{% extends "base_watch.html" %}
{% block content %}
<section class="card wide capture-card">
  <div class="card-header">
    <div>
      <p class="eyebrow">Realtime watch</p>
      <h1>NBDetect monitor</h1>
    </div>
    <span class="pill">{{ state.status|capitalize }}</span>
  </div>
  <div class="control-grid">
    <label>
      <span>Checkpoint</span>
      <div class="input-row">
        <input type="text" id="model-display" placeholder="No model selected" readonly />
        <button id="browse-btn" class="secondary">Browse…</button>
        <input type="file" id="file-input" accept=".pt,.pth" hidden />
      </div>
    </label>
    <label>
      <span>Alert threshold</span>
      <input type="range" id="threshold" min="0.1" max="0.95" step="0.05" value="{{ state.threshold }}" />
      <small class="helper-text">Trigger alert when biting probability ≥ <span id="threshold-value">{{ state.threshold }}</span></small>
    </label>
    <div class="button-set">
      <button id="start-btn" class="primary" disabled>Start monitoring</button>
      <button id="stop-btn" class="ghost" disabled>Stop</button>
    </div>
  </div>
</section>

<div class="monitor-grid">
  <section class="card compact preview-card">
    <div class="card-header small">
      <div>
        <p class="eyebrow">Live feed</p>
        <h2>Camera stream</h2>
      </div>
      <span class="helper-text">Alerts freeze the stream until acknowledged.</span>
    </div>
    <div class="preview-frame small">
      <img id="video-feed" src="{{ url_for('video_feed') }}" alt="Video feed appears once monitoring starts." />
      <div id="overlay-alert" class="alert-overlay hidden">
        <div class="alert-box">
          <p class="eyebrow">Warning</p>
          <h3>Nail biting detected</h3>
          <p>Resume monitoring to continue.</p>
          <button id="ack-btn" class="primary">Resume monitoring</button>
        </div>
      </div>
    </div>
  </section>

  <section class="card status-card compact">
    <div class="status-card-header">
      <div>
        <p class="eyebrow">Status</p>
        <h2>Detection summary</h2>
      </div>
    </div>
    <div class="status-layout">
      <div class="status-progress">
        <div class="status-line">
          <span>Biting probability</span>
          <strong id="biting-prob">{{ state.probabilities.biting }}</strong>
        </div>
        <div class="status-line">
          <span>Not biting probability</span>
          <strong id="not-biting-prob">{{ state.probabilities.not_biting }}</strong>
        </div>
        <div class="status-line">
          <span>Last detection</span>
          <strong id="last-detection">{% if state.last_detection %}{{ state.last_detection }}{% else %}-{% endif %}</strong>
        </div>
      </div>
      <div class="status-feedback">
        <p id="status-message">{{ state.message }}</p>
      </div>
    </div>
  </section>
</div>

<script>
  const statusUrl = "{{ url_for('status_route') }}";
  const loadModelUrl = "{{ url_for('load_model_route') }}";
  const uploadModelUrl = "{{ url_for('upload_model_route') }}";
  const startUrl = "{{ url_for('start_route') }}";
  const stopUrl = "{{ url_for('stop_route') }}";
  const ackUrl = "{{ url_for('acknowledge_route') }}";
  const thresholdUrl = "{{ url_for('threshold_route') }}";

  const modelDisplay = document.getElementById("model-display");
  const browseBtn = document.getElementById("browse-btn");
  const fileInput = document.getElementById("file-input");
  const thresholdInput = document.getElementById("threshold");
  const thresholdValue = document.getElementById("threshold-value");
  const startBtn = document.getElementById("start-btn");
  const stopBtn = document.getElementById("stop-btn");
  const overlay = document.getElementById("overlay-alert");
  const ackBtn = document.getElementById("ack-btn");
  const statusMessage = document.getElementById("status-message");
  const bitingProbEl = document.getElementById("biting-prob");
  const notBitingProbEl = document.getElementById("not-biting-prob");
  const lastDetectionEl = document.getElementById("last-detection");

  let modelReady = {{ "true" if state.model_path else "false" }};
  if (modelReady) startBtn.disabled = false;

  thresholdInput.addEventListener("input", () => {
    thresholdValue.textContent = Number(thresholdInput.value).toFixed(2);
  });

  thresholdInput.addEventListener("change", () => {
    updateThreshold(Number(thresholdInput.value));
  });

  browseBtn.addEventListener("click", () => fileInput.click());

  fileInput.addEventListener("change", async () => {
    if (!fileInput.files.length) return;
    const file = fileInput.files[0];
    modelDisplay.value = file.name;
    const formData = new FormData();
    formData.append("file", file);
    try {
      const response = await fetch(uploadModelUrl, { method: "POST", body: formData });
      const payload = await response.json();
      if (!response.ok) {
        alert(payload.error || "Unable to load checkpoint.");
        return;
      }
      modelReady = true;
      statusMessage.textContent = "Model loaded. You can start monitoring.";
      if (payload.modelPath) {
        modelDisplay.value = payload.modelPath;
      }
      if (!["running", "alert"].includes(payload.status)) {
        startBtn.disabled = false;
      }
    } catch (error) {
      alert("Failed to load model. Check console.");
      console.error(error);
    }
  });

  startBtn.addEventListener("click", async () => {
    try {
      const response = await fetch(startUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ threshold: Number(thresholdInput.value) }),
      });
      const payload = await response.json();
      if (!response.ok) {
        alert(payload.error || "Unable to start monitoring.");
        return;
      }
      startBtn.disabled = true;
      stopBtn.disabled = false;
    } catch (error) {
      console.error(error);
    }
  });

  stopBtn.addEventListener("click", async () => {
    try {
      await fetch(stopUrl, { method: "POST" });
      stopBtn.disabled = true;
      startBtn.disabled = false;
    } catch (error) {
      console.error(error);
    }
  });

  ackBtn.addEventListener("click", async () => {
    try {
      await fetch(ackUrl, { method: "POST" });
    } catch (error) {
      console.error(error);
    } finally {
      overlay.classList.add("hidden");
    }
  });

  async function updateThreshold(value) {
    thresholdValue.textContent = value.toFixed(2);
    try {
      await fetch(thresholdUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ threshold: value }),
      });
    } catch (error) {
      console.error(error);
    }
  }

  async function pollStatus() {
    try {
      const response = await fetch(statusUrl);
      const payload = await response.json();
      bitingProbEl.textContent = payload.probabilities.biting.toFixed(2);
      notBitingProbEl.textContent = payload.probabilities.not_biting.toFixed(2);
      statusMessage.textContent = payload.message || "";
      if (payload.last_detection) {
        lastDetectionEl.textContent = payload.last_detection;
      } else {
        lastDetectionEl.textContent = "-";
      }
      if (Math.abs(payload.threshold - Number(thresholdInput.value)) > 1e-3) {
        thresholdInput.value = payload.threshold;
        thresholdValue.textContent = Number(payload.threshold).toFixed(2);
      }
      if (payload.model_path) {
        modelReady = true;
        modelDisplay.value = payload.model_path;
      }
      if (payload.status === "running" || payload.alert) {
        startBtn.disabled = true;
        stopBtn.disabled = false;
      } else {
        stopBtn.disabled = true;
        startBtn.disabled = !modelReady;
      }
      if (payload.alert) {
        overlay.classList.remove("hidden");
      } else {
        overlay.classList.add("hidden");
      }
    } catch (error) {
      console.error("Status poll failed", error);
    } finally {
      setTimeout(pollStatus, 1200);
    }
  }

  pollStatus();
</script>
{% endblock %}
